/* SPRITE AND ANIMATION *
Simple sprite class that can display a single frame image or an indicated
frame from a multi-frame image (assumed frame order TL->BR)

TODO:
+add rotation to spite draw method
+allow aligning to edge, corner or arbitrary position
+reverse frame order so it's BL->TR
*/


/* ANIM STRING TO ANIM ARRAY *
This function takes a string in the form "0-7:3,6-1", "1,2,3,5,8,13" etc.
and returns an array of parameters to be interpreted by the animation system.
The returned array takes the following form:
{start, end, time, start, end, time ...}
<start>-<end> is a range
:<time> sets the number of game frames to display each animation frame for

4 becomes { 4, 4, -1 }
4:30 becomes { 4, 4, 30 }
0-7 becomes { 0, 7, -1 }
0-7:3 becomes { 0, 7, 3 }
-1 indicates that the default time value should be used.
*/
function parseAnim(astr) {
	var str = new String(astr);
	var cmdStrArr = str.split(','); //array of commands as strings
	var cmdArr = new Array(); //array that will be returned
	var start, end, time; //parameters to be written to cmdArr
	
	var temp;
	for (var i = 0; i < cmdStrArr.length; i++) {
		temp = cmdStrArr[i].split(':');
		if (temp.length == 2) { //time parameter contained!
			time = parseInt(temp[1], 10);
		} else {
			time = SpriteAnimState.DEFAULT_FRAME_DURATION;
		}
		
		temp = temp[0].split('-');
		if (temp.length == 2) { //range, not single frame
			start = parseInt(temp[0], 10);
			end = parseInt(temp[1], 10);
		} else {
			start = parseInt(temp[0], 10);
			end = start;
		}
		
		cmdArr[cmdArr.length] = start;
		cmdArr[cmdArr.length] = end;
		cmdArr[cmdArr.length] = time;
	}
	return cmdArr;
}



function validateAnimArray(arr) {
	if (arr.length == 0) return false;
	for (var i = 0; i < arr.length; i++)
	{
		if (isNaN(arr[i])) {
			return false;
		}
	}
	return true;
}


/* SPRITE *
very simple sprite class that supports animation
*/
function Sprite(img, framesX, framesY, numFrames) {
	this.img = img;
	this.framesX = framesX || 1;
	this.framesY = framesY || 1;
	this.numFrames = numFrames || (this.framesX * this.framesY);
	this.frameWidth = Math.floor(this.img.width / this.framesX);
	this.frameHeight = Math.floor(this.img.height / this.framesY);
	this.center = true; //true: sprite origin is center, false: origin is top left corner
}

Sprite.prototype.draw = function(ctx, x, y, frame)
{
	if (this.center) {
		x -= this.frameWidth * 0.5;
		y -= this.frameHeight * 0.5;
	}
	x = Math.floor(x);
	y = Math.floor(y);
	
	if (this.numFrames > 1) { 
		var xofs, yofs;
		if (frame < 0 || frame >= this.numFrames) return;
		if (this.framesY > 1) { //need to figure out frame as x,y index
			xofs = frame % this.framesX;
			yofs = Math.floor((frame - xofs) / this.framesX);
			xofs *= this.frameWidth;
			yofs *= this.frameHeight;
			ctx.drawImage(this.img, xofs, yofs, this.frameWidth, this.frameHeight, x, y, this.frameWidth, this.frameHeight);
		} else { //slightly quicker calculation as no y coord needed
			xofs = frame * this.frameWidth;
			ctx.drawImage(this.img, xofs, 0, this.frameWidth, this.frameHeight, x, y, this.frameWidth, this.frameHeight);
		}
	} else {
		ctx.drawImage(this.img, x, y);
	}
}


/* SPRITE ANIMATION STATE *
Handles the animation parameters generated by the parseAnim function
by storing all the current parameters and updating as requested.
playbackState =
  0 - Don't animate
  n - Play n times
  -1 - Loop forever
anim - an animation array reference
animIndex - index into the anim array (first param in 3 param group)
currentFrame - current frame
firstFrame - first frame of current anim command
lastFrame - last frame of curent anim command
nextFrameIn - next frame in number of frames remaining

Animations should be stored in the class the animation belongs to as
static variables defined as thus:
function Enemy() {
	this.animState = new SpriteAnimState();
}

Enemy.sprite = new Sprite(enemyImage, 16, 4, 4);

Enemy.ANIM_WALK = parseAnim("0-7,6-1");
Enemy.ANIM_JUMP = parseAnim("8-9,10:6,9-8");

Whilst the sprite should be stored statically somewhere, the animation
data should be created anew for each instance of an animated object unless
everything being in sync is desired.
*/
function SpriteAnimState(anim, playbackState) {
	this.anim = anim || null;
	this.animIndex = 0;
	this.currentFrame = (this.anim) ? this.anim[0] : 0;
	this.firstFrame = (this.anim) ? this.anim[0] : 0;
	this.lastFrame = (this.anim) ? this.anim[1] : 0;
	this.nextFrameIn = (this.anim) ? this.anim[2] : 0;
	this.playbackState = playbackState || 0;
	this.playbackCount = 0; //increment each time anim played as a way to store a useful state for triggering other events
}

SpriteAnimState.prototype.equals = function(o) {
	this.anim = o.anim;
	this.animIndex = o.animIndex;
	this.currentFrame = o.currentFrame;
	this.firstFrame = o.firstFrame;
	this.lastFrame = o.lastFrame;
	this.nextFrameIn = o.nextFrameIn;
	this.playbackState = o.playbackState;
	this.playbackCount = o.playbackCount;
}

//can change this depending on game framerate. This is for 10fps animation at 60fps
SpriteAnimState.DEFAULT_FRAME_DURATION = 6;

SpriteAnimState.prototype.reset = function() {
	this.animIndex = 0;
	this.currentFrame = this.anim[0];
	this.firstFrame = this.anim[0];
	this.lastFrame = this.anim[1];
	this.nextFrameIn = this.anim[2];
	this.playbackState = 0;
	this.playbackCount = 0;
}

SpriteAnimState.prototype.setAnim = function(anim, playbackState) {
	this.anim = anim;
	this.reset();
	this.playbackState = playbackState || 0;
}

SpriteAnimState.prototype.update = function() {
	if (!this.anim || !this.playbackState) return; //quit if not ready
	
	if (this.nextFrameIn > 0) {
		this.nextFrameIn--;
	} else { //update frame
		if (this.currentFrame == this.lastFrame) { //update parameters
			this.animIndex += 3;
			if (this.animIndex >= this.anim.length) { //loop
				this.animIndex = 0;
				if (this.playbackState > 0) {
					this.playbackState--;
					this.playbackCount++;
				}
			}
			
			this.firstFrame = this.anim[this.animIndex];
			this.lastFrame = this.anim[this.animIndex + 1];
			this.nextFrameIn = this.anim[this.animIndex + 2];
			this.currentFrame = this.firstFrame;
			
		} else { //simple frame update
			if (this.firstFrame < this.lastFrame) this.currentFrame++;
			else this.currentFrame--;
			this.nextFrameIn = this.anim[this.animIndex + 2];
		}
	}
}

SpriteAnimState.prototype.toString = function() {
	var rv = new String("index:");
	rv += this.animIndex + ", cf:";
	rv += this.currentFrame + ", ff:";
	rv += this.firstFrame + ", lf:";
	rv += this.lastFrame + ", nft:";
	rv += this.nextFrameIn + ", pbs:";
	rv += this.playbackState + ", pbc:";
	rv += this.playbackCount;
	return rv;
}

